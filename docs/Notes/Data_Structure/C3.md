栈和队列是两种重要的线性结构。栈和队列是限定插入和删除只能在表的**端点**进行的线性表。

由于栈的操作具有**后进先出**的固有特性，使栈成为程序设计中有用的工具。另外 ，如果问题求解过程中具有**后进先出**的天然特性则求解的算法中必须利用**栈**。

由于队列的操作具有**先进先出**的特性，使得队列成为程序设计中解决类似排队问题的有用工具。

## 栈

### 栈的定义和特点

**栈**(stack)是一种**后进先出LIFO**(Last In First Out)的线性表，在表尾进行插入或删除操作。

**栈顶**、**栈底**、不含元素的空表称为**空栈**。

插入元素到栈顶(表尾)的操作叫**入栈**(压栈)👉**PUSH()**

从栈顶(表尾)删除最后一个元素的操作称为**出栈**(弹栈)👉**POP()**

栈和线性表唯一的区别在于运算规则。线性表插入删除位置任意而栈只能对表尾(栈顶)的元素进行插入和删除操作。(后进先出的原则)

> 常用案例：进制转换，括号匹配的检验。



由于栈本身就是线性表，于是栈也有**顺序栈**和**链栈**两种实现方式

### 栈的顺序表示

**存储方式**：同一般的顺序表结构完全相同，利用(数组)一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，栈底一般在低地址端。

**top指针**，指示栈顶元素在顺序栈的位置

**base指针**，指示栈底元素在顺序栈的位置


但是为了方便操作通常top指针指向<u>栈顶元素之上的下标地址指向线性表中的an+1</u>

另外，用**stacksize**表示栈的最大容量（栈最多可以存放的元素个数）

使用数组作为顺序栈的存储方式的**特点**：简单、方便、易产生溢出(数组大小固定)

**上溢**(overflow)：栈已满又要压入元素

**下溢**(underflow)：栈已空，还要弹出元素

!> **注意**：上溢是一种错误，使问题的处理无法进行，而下溢一般认为是一种结束条件，即问题处理结束。

**栈中元素个数**：`top - base`

**空栈**：`base == top`

**栈满**：`top-base == stacksize`

> 栈满时处理方法：
>
> 1. <u>报错</u>，返回操作系统
>
> 2. <u>分配更大空间</u>，作为栈存储空间，再将原栈内容移入新栈。（但尤其数据量大时会很费时）

### 顺序栈的表示和实现

<br>

## 列

### 列的定义和特点

**队列**(queue)是一种**先进先出FIFO**(First In First Out)的线性表，只在表尾插入，表头删除。

表尾称**队尾**(rear)，表头称**队头**(front)。插入元素称**入队**，删除元素称**出队**。

队列的存储结构为**顺序队列**、**链式队列**（常用**循环顺序队**）

> 常用案例：舞伴问题。

**初始**：`front = rear = 0`

**入队**：`base[rear] = x;	rear++;`

**出队**：`x = base[front];	front++;`

**空队**：`front == rear;`

解决假上溢的方法——引入**循环队列**

`base[0]`接在`base[MAXQSIZE - 1]`之后，若`rear + 1 == M`，则令`rear = 0`

**实现方法**：利用模运算（mod）

**插入元素**：`Q.base[Q.rear] = x;	Q.rear = (Q.rear + 1) % MAXQSIZE;`

**删除元素**：`x = Q.base[s.front];	Q.front = (Q.front + 1) % MAXQSIZE`