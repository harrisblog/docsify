## 线性表的概念及运算

### **线性表的逻辑结构**

线性表是n个类型相同的数据元素的<u>有限序列</u>，数据元素之间是<u>一对一</u>的关系，即每个数据元素最多有一个直接前驱和一个直接后继。

### **线性表的特点**

**同一性**：线性表由同类数据元素组成，每一个a~i~必须属于同一数据对象。

**有穷性**：线性表由有限个数据元素组成， 表长度就是表中数据元素的个数。 

**有序性**：线性表中表中相邻数据元素之间存在着序偶关系<a~i~, a~i+1~>。    

## 线性表的顺序存储

### 基本操作代码

不含ma~i~n函数

```c
#include<stdio.h>
#include <malloc.h>
#include <process.h>
#define MaxSize 100
typedef int Status;
typedef int ElemType;
typedef struct {
	ElemType elem[MaxSize];
	int last;
} SeqList;

//初始化
void InitList(SeqList &L) {
	L.last=-1;
}

//赋值
void Assignment(SeqList &L) {
	//为顺序表L的各元素赋值.
	int i, N;
	printf("请输入顺序表中元素的个数:");
	scanf("%d",&N);
	printf("请输入顺序表中的元素:");
	for(i=0; i<N; i++) {
		scanf("%d", &L.elem[i]);
		L.last++;
	}
}

//判断是否为空表
void ListEmpty(SeqList &L) {
	if (L.last < 0) {
		printf("为空\n");
	} else {
		printf("非空\n"); 
	}
}

//按内容定位，返回元素序号
void Locate(SeqList &L) {
	int i = 0, e;
	printf("请输入你想查找的元素：\n");
	scanf("%d", &e); 
	while((i <= L.last) && (L.elem[i] != e)) {
		i++;
	}

	if(i<=L.last ) {
		printf("%d的序号是%d\n", e,i+1);
	} else {
		printf("抱歉，没找到%d\n", e); 
	}
}

//插入（在第i个位置前插入一个元素e）
Status InsList(SeqList &L, int i, ElemType e) {
	if((i<1) || (i>L.last+2)) { /*判断是否合法*/
		printf("插入位置值不合法");
		return 0; 
	}

	if (L.last == MaxSize - 1) {
		printf("表已满\n");
		return 0; 
	}

	//为插入元素，而移动位置i后所有元素的位置
	for (int k = L.last; k >= i-1; k--) { 
		L.elem[k+1] = L.elem[k];
	}
	//赋值
	L.elem[i-1] = e;
	L.last++;
	printf("插入成功");
}

//删除（在第i个位置前删除一个元素e）
Status Delete(SeqList &L, int i) {
	//判断输入是否合法
	if((i < 1) || (i > L.last + 1)) {
		printf("删除位置不合法！"); 
		return 0; 
	} 
	
	for(int k = i-1; k < L.last+1; k++) {
		L.elem[k] = L.elem[k+1];
	}
	L.last--;
} 

//遍历
void Traverse(SeqList &L) {
	for (int i = 0; i < L.last+1; i++) {
		printf("%d ", L.elem[i]);
	}
	printf("\n");
}
```

### 顺序表优缺点

**优点**：

1. 无需为表示结点间的逻辑关系而增加额外的存储空间。

2. 可方便地随机**存取**表中的任一元素。

**缺点**：

1. **插入**或**删除**元素需要移动大量元素，效率低下。

2. 存储分配只能预先进行静态分配，可能造成一部分空间长期闲置或空间溢出。

## 线性表的链式存储

为了克服顺序表的缺点，可采用动态存储方法即**链式存储**，采用链式存储结构的线性表称为**线性链表**。

**线性链表分类**：

- **链接方式**：单链表、双链表、循环链表

	- 单链表：结点只有一个指针域

	- 双链表：节点有两个指针域

	- 循环链表：首尾相接

- **实现方式**：动态链表和静态链表

**Q：如何表示数据元素之间的逻辑关系呢？**

**A：**它既存储**自身数据**同时也存储**下一个元素的地址**。存储数据元素的域称为**数据域**，存储直接后继位置的域称为**指针域**。指针域中存储的信息称作**指针**或**链**。这两部分信息组成a~i~的存储映象称为**结点**(Node)。n个结点(a~i~(1≤i≤n)的存储映象链结成一个链表，即为**线性表**。把链表中第1个结点的存储位置叫**头指针**。最后一个元素没有直接后继，所以规定最后一个结点<u>指针为空</u>(通常用**NULL**或**^**表示)

单链表由头指针唯一确定，因此单链表<u>可用头指针名字来命名</u>。

### 单链表

**概念**：每个数据元素（结点）由两个域构成：**数据域**和**指针域**。

链表通过每个结点的指针域按<u>逻辑顺序</u>连接在一起。由于链表的每个结点只有一个指针域，故将其又称为**单链表**。

为了更加方便对链表进行操作，会在单链表的第1个结点前附设一个**头结点**，头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向线性表第1个元素的结点。
![](https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/DataStructure_Note/image-20210424155953569.png)

#### 基本操作代码



#### 建立单链表

##### 头插法

- 从一个空表H开始，H为头结点
- 每次读入数据，申请新结点S
- 将读入数据存放到新结点的数据域中
- 将新结点插入到当前链表的表头
- 直至读入结束标志为止

##### 尾插法

- 从一个空表H开始，H为头结点，r指向表尾

- 每次读入数据，申请新结点S

- 将读入数据存放到新结点的数据域中

- 将新结点插入到当前链表的表头，r指向S

- 直至读入结束标志为止

## 循环链表

循环链表是头尾相接的链表(即表中最后一个结点的指针域指向头结点，整个链表形成一个**环**)

**优点**：从表中任一结点出发均可访问全部结点

**循环链表和单链表差异**：当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同。在单链表中，判别条件为`p!=NULL`或`p->next!=NULL`,而循环单链表的判别条件为`p!=L`或`p->next!=L`。

## 双向链表