**指令的格式**：

​	**机器指令的格式**：

​		每条机器指令都由”0“和”1“组成，包含操作码和地址码。

​		格式：[操作码] [地址码]

​		其中，操作码：说明指令的性质和功能；地址码：说明参与运算的操作数或操作数的地址；

​	**符号指令的格式**：

​		用符号来表示操作码和地址码。

​		格式：[操作码助记符] [操作数助记符]

​		例子：

```assembly
MOV AL,3	#把3送给AL
MOV BL,4	#把4送给BL
ADD AL,BL	#把AL和BL相加，结果送给AL
```

## 8086 CPU寻址方式⭐

微机中哪些地方可以存放操作数？

答：寄存器组，内存储器，I/O接口。

### 立即寻址

**特点**：操作数直接存放在<u>指令</u>中，紧跟在操作码之后。

**表示方法**：立即数，也就是<u>常量</u>，二进制数、八进制数、十进制数、十六进制数均可。

### 寄存器寻址

**特点**：操作数在CPU内部的某个寄存器中。

**表示方法**：寄存器的名称（如AX、BX等）。

### 存储器寻址

**特点**：操作数存放在内存单元中。

1. 指令中如何描述操作数？

	答：在指令中用逻辑地址表示操作数。

	段地址：有效地址

	> 有效地址EA可有以下三部分组成
	>
	> - 基址寄存器（BX、BP）
	>
	> - 变址寄存器内容 （SI、DI）
	>
	> - 位移量（8位或16位立即数）

2. CPU如何找到操作数？

	物理地址和逻辑地址的转换

	物理地址PA = 段地址DS × 16 + 偏移地址(EA)

#### 直接寻址

有效地址EA由<u>指令直接给出</u>

**表示方法**：[有效地址EA]

物理地址：PA = DS × 16 + EA   

#### 寄存器间接寻址

有效地址EA由某个寄存器给出  

**表示方法**：[BX]、[BP]、[SI]、[DI]

物理地址：

PA = (DS) × 16 + (BX)/(SI)/(DI)

PA = (SS) × 16 + (BP)

#### 基址寻址

**表示方法**：[基址寄存器 + 位移量]

物理地址：

PA = (DS) × 16 + (BX)

PA = (SS) × 16 + (BP)

#### 变址寻址

**表示方法**：[变址寄存器 + 位移量]

物理地址：PA=(DS) × 16 + (SI)/(DI)

#### 基址变址寻址

**表示方法**：[基址寄存器 + 变址寄存器]

物理地址：

PA=(DS) × 16 + (BX) + (变址寄存器)

PA=(SS) × 16 + (BP) + (变址寄存器) 

#### 基址变址位移寻址

**表示方法**：[基址寄存器 + 变址寄存器 + 位移量]

物理地址：

PA=(DS) × 16 + (BX) + (变址寄存器) + 位移量

PA=(SS) × 16 + (BP) + (变址寄存器) + 位移量 

<br>

## 8086 CPU指令系统⭐😱

### 指令构成的基本原则

1. 源、目的操作数的<u>字长一致</u>

	MOV  AL,BX ❌

2. 源、目的操作数<u>不能同为内存单元</u>

	MOV  [SI],[DI] ❌

3. 立即数不能作目的操作数

	MOV  12H,AL ❌

> 左目右源 → [目的操作数d],[源操作数s]
>



### 8086 CPU指令分类

#### 一、数据传送指令（14条）⭐

- 实现在寄存器、存储器及I/O端口之间传送数据
- 除<u>标志传送指令</u>外，指令执行结果都<u>不影响</u>标志寄存器

<img src="https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210323204254049.png" alt="" style="zoom:80%;" />

##### MOV指令

 **格式**：MOV d, s

 **功能**： (d) ← (s)

 **说明**：将s的内容传送给d，s保持不变

> MOV指令注意事项：
>
> 1. <u>立即数不能直接送段寄存器</u>
>
> 2. d、s不能同为段寄存器

##### XCHG  指令

**格式**： XCHG d，s

**功能**： (d) ↔ (s)

**说明**：交换s和d的内容，s和d的<u>内容都变化</u>

> XCHG指令注意事项：
>
> 1. 不允许使用立即数
>
> 2. 不允许使用段寄存器

##### 堆栈操作指令 PUSH和POP

- 堆栈是存储器中的特定区域。

- 堆栈存取规则：后进先出(LIFO或FILO)。

- 在堆栈中始终有一个栈顶单元，该单元的地址为**SS:SP**。

- 堆栈操作类型：压入和弹出，均以<u>字</u>为单位进行。

- 不管压入还是弹出总是对栈顶进行操作，且栈顶指针SP会<u>自动修改</u>以保持<u>始终指向新的栈顶</u>。 

###### 进栈指令 PUSH

**格式**： PUSH s~16~

**功能**： SP ← SP－2，(SP) ← s~16~ 

**说明**：将s指定的16位操作数压入堆栈 。

###### 出栈指令 POP

**格式**： POP d~16~

**功能**： d~16~ ← (SP)，SP ← SP＋2 

**说明**：将栈顶的16位操作数弹出，送入d。

> -2，+2是指堆栈指针移动2个字节

> 堆栈操作指令注意事项：
>
> 1. 不允许使用立即数
>
> 2. 必须以<u>字</u>为单位
>

##### 查表转换指令 XLAT

**格式**： XLAT 

**功能**： AL ← DS : [BX＋AL] 

**说明**：将数据段中首单元偏移地址在BX，顺序号在AL的表的内容取出送AL。 

XLAT指令相当于在一个字节数组中寻找某个元素：

1. 数组的首地址 → BX

2. 数组元素的下标 → AL

3. 寻找到的数组元素放在AL中

##### 取有效地址指令 LEA

**格式**： LEA reg~16~，mem 

**功能**： reg~16~ ← mem~EA~

**说明**：将mem指定的存储器操作数的有效地址取至16位的通用寄存器reg~16~中 。 

> 堆栈操作指令注意事项：
>
> LEA指令注意事项：
>
> 1. 源操作数必须为存储器寻址方式
>
> 2. 目的操作数是16位通用寄存器，不能是段寄存器
>

##### 端口输入指令 IN

**格式**： 

IN AL, port~8~

IN AL, DX; 口地址为16位必须送DX

IN AX, port~8~

IN AX, DX

**功能**：从I/O端口中读取一个或两个字节到CPU内的AL或AX寄存器。

**说明**：端口操作数用该端口的地址表示。

##### 端口输出指令OUT

**格式**： 

OUT  port~8~, AL

OUT  DX, AL   ;口地址为16位必须送DX

OUT  port~8~, AX

OUT  DX, AX

**功能**：向I/O端口中输出一个或两个字节。

**说明**：端口操作数用该端口的地址表示。

<br>


#### 二、算术运算指令（20条）⭐

实现加法、减法、乘法、除法、BCD码运算后的调整

大部分指令影响标志寄存器中的状态标志位

![](https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210323204916454.png)
![](https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210323205034384.png)

##### 不带进位加法指令 ADD

**格式**：ADD d, s

**功能**： (d) ← (d) + (s)

**说明**：操作数不能使用段寄存器

##### 带进位加法指令 ADC

**格式**：ADC d, s

**功能**： (d) ← (d) + (s) + CF

**说明**：将**目的操作数d**与**源操作数s**和**进位标志CF**相加结果送回d中

例题：

设AX＝1000H，CF＝1，分析以下指令的执行结果（AX=? CF=?）

（1）ADD AX，100H;	<u>AX=1100H，CF=0</u>

（2）ADC AX，100H;	<u>AX=1101H，CF=0</u>

（3）ADC AH，0F0H;	<u>AX=0100H，CF=1</u>



##### 加一指令 INC

**格式**：INC d

**功能**：(d) ← (d) + 1

**说明**：将目的操作数d加1后结果送回d中

> **注意**：<u>INC不影响CF标志</u>

例题：

设AX＝0FF00H，CF＝0，则执行下列指令后，AX=? CF=?

（1）INC AX;	<u>AX=0FF01H，CF=0</u>

（2）INC AH;	<u>AX=0000H，CF=0</u>



##### 不带进位减法指令 SUB

格式：SUB d,s

功能： (d) ← (d) - (s)

说明：将目的**操作数d**与**源操作数s**相减结果送回d中

##### 带进位减法指令 SBB

**格式**：SBB d,s

**功能**： (d) ← (d) - (s) - CF

**说明**：将目的**操作数d**与**源操作数s**和**进位标志CF**相减结果送回d中

例题：

设AX＝1101H，CF＝1，则执行下列指令后，AX=? CF=?

（1）SUB AX，100H;	<u>AX=1001H，CF=0</u>

（2）SBB AX，100H;	<u>AX=1000H，CF=0</u>

（3）SBB AH，11H;	<u>AX=0FF01H，CF=1</u>

> 第三题：估计如果借位或进位了，前面就得加个0



##### 减一指令 DEC

**格式**：DEC d

**功能**： (d) ← (d) - 1

**说明**：将目的操作数d减1后结果送回d中

> 注意：<u>DEC不影响CF标志</u>
>

##### 取负指令NEG

**格式**：NEG d

**功能**： (d) ← $\overline{\text{d}}$ +1

**说明**：将目的操作数**取负**后送回d中

**例题**：

设AX＝00FFH，则执行下列指令后，AX=?

NEG AX;	<u>AX = FF01H</u>

NEG AL;	<u>AX = 0001H</u>



##### 比较指令CMP

格式：CMP d，s

功能： (d) - (s)

说明：仅将**目的操作数d**与**源操作数s**相减，结果并不送回d中

<br>

~~在此插个BCD码概念~~

**BCD码**

**概念**：BCD码（Binary-Coded Decimal）亦称二进码十进数或二 - 十进制代码。用**4位二进制数**来表示**1位十进制数中的0~9这10个数码**。通俗点，BCD码就是对于8位数字来说，<u>高4为和低4为均不超过9的数字</u>。

##### 加法的压缩BCD码调整指令 DAA

**格式**：DAA

**功能**：对AL中的压缩BCD码加法结果进行调整。

**说明**：必须紧跟在ADD/ADC指令之后出现。

<img src="https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210324160243732.png" alt=""  />

> 高低位都满足则加66H

例题：

1. 设AL＝25H，BL＝37H，问执行下列指令序列后，AL=? CF=?

	ADD AL，BL

	DAA

	> 25H+37H=5CH
	>
	> 修正：5CH+6H=62H=01100010B
	>
	> AL=62H=62~BCD~，CF=0

2. CPU执行下列指令序列后，AL=? CF=?

	MOV AL，68H

	 ADD AL，89H

	 DAA

	> 68H+89H=(1)F1H	（大于9，AF=1）
	>
	> 修正：F1H+66H=(1)57H=(1)01010111B
	>
	> AL=57H=57BCD，CF=1	（表示结果为157）



#### 三、逻辑运算与移位指令⭐

##### 逻辑运算指令

- 主要实现与、或、非、异或、测试等逻辑运算。
- 除逻辑“非”指令不影响标志外，其他逻辑运算指令均影响标志SF、ZF和PF，而OF和CF一定被置0，AF不确定。

<img src="https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210327211600621.png" style="zoom: 67%;" />

###### 逻辑“与”指令 AND

**格式**：AND d, s

**功能**： (d) ← (d) ∧ (s)

**说明**：将目的操作数d与源操作数s按位相“与”结果送回d中。

**特点**：“与” 运算常用于使某些位<u>清0</u>。

例题：

写出指令完成以下要求

（1）屏蔽AL的0，1两位。

 AND  AL，0FCH

（2）将AH的高4位清0。

 AND  AH，0FH

（3）将BX的低4位清0。

 AND  BX，0FFF0H

###### 逻辑“或”指令 OR

**格式**：OR d, s

**功能**： (d) ← (d) ∨ (s)

**说明**：将目的操作数d与源操作数s按位相“或”结果送回d中。

**特点**：“或” 运算常用于使某些位<u>置1</u>。

例题：

写出指令完成以下要求

（1）将AL的0，1两位置1。

​	OR  AL，03H

（2）将AH的高4位置1。

​	 OR  AH，0F0H

（3）将BX的低4位置1。

​	OR  BX，000FH



###### 逻辑“异或”指令 XOR

**格式**：XOR d, s

**功能**： (d) ← (d) ⊕ (s)

**说明**：将目的操作数d与源操作数s按位相“异或”结果送回d中。

**特点**：“异或” 运算常用于使某些位<u>取反</u>。

例题：

写出指令完成以下要求

（1）对AL的0，1两位取反。

​	 XOR  AL，03H

（2）对CL的1,2,3,4,5位取反，其它位不变。

​	 XOR  CL，3EH



###### 逻辑“非”指令 NOT

**格式**：NOT d

**功能**： (d) ← (d) 

**说明**：将目的操作数d取反后结果送回d中。

###### 测试指令 TEST

**格式**：TEST d, s

**功能**：(d) ∧ (s)

**说明**：将目的操作数d与源操作数s按位相“<u>与</u>”，只<u>影响标志位不回送结果</u>，常用于测试某些位是0或1。

例题：

测试AL的最高位是0/1？

TEST  AL，80H

若SF=1，则AL最高位为1；

若SF=0，则AL最高位为0；

若ZF=1，则AL最高位为0；

若ZF=0，则AL最高位为1；



##### 移位运算指令

- 对8位或16位的通用寄存器或存储器内容进行移位，移位次数可以为1～255。

- 若移位次数为1则可直接写在指令中，若次数为2～255则不能直接写在指令中，必须先将次数放在寄存器CL中，指令中只能写<u>CL</u>，移位结束后CL的值不变。

- 影响标志OF、SF、ZF、PF、CF，但AF不确定。当移位次数为1时，若移位结果使最高位符号位发生变化，则溢出标志OF＝1，否则OF＝0；当移位次数超过1时，OF无效。

<img src="https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210327213112052.png" style="zoom:80%;" />

###### 逻辑左移指令 SHL

**格式**：SHL d，count（1/CL） 

**功能**：逻辑左移

**说明**：将目的操作数d左移count位，右边补0，左边入CF。

> 逻辑左移1位相当于无符号数<u>乘以2！</u>
>

例题：

**BX乘以2：**

SHL  BX，1

**BX乘以3：**

MOV  AX，BX

SHL  BX，1

ADD  BX，AX

**BX乘以4：**

MOV  CL，2

SHL  BX，CL

###### 逻辑右移指令 SHR

**格式**：SHR d, count（1/CL） 

**功能**：逻辑右移

**说明**：将目的操作数d右移count位，左边补0，右边入CF。

> 逻辑右移1位相当于无符号数<u>除以2！</u>
>

###### 算术左移指令 SAL

**格式**：SAL d，count（1/CL） 

**功能**：同逻辑左移完全相同

###### 算术右移指令 SAR

**格式**：SAR d，count（1/CL） 

**功能**：算术右移

**说明**：将操作数d的内容右移，左边不变，右边移入CF中.

> 算术右移1位相当于有符号数<u>除以2！</u>
>

###### 循环左移指令 ROL

**格式**：ROL d，count（1/CL） 

**功能**：循环左移

**说明**：将操作数d的内容左移，最高位循环移入最低位，同时移入CF。

###### 循环右移指令 ROR

**格式**：ROR d, count（1/CL） 

**功能**：循环右移

**说明**：将操作数d的内容右移，最低位循环移入最高位，同时移入CF。

#### 四、串操作指令

省略

#### 五、控制转移指令😱

- 控制转移指令用来控制程序的执行顺序，用于实现分支、循环、过程调用/返回、中断调用/返回等程序结构。

- CS:IP总是指向下一条即将执行的指令的地址，通过改变IP和CS的值，可以改变程序的执行顺序，但程序中不能使用MOV指令直接改变CS和IP的值，只能通过**控制转移指令**实现。

![](F:/360MoveData/Users/Administrator/Pictures/%E5%8D%9A%E5%AE%A2%E4%B8%93%E7%94%A8/CDN/posts/Microcomputer_Note/image-20210331183526533.png)
![](F:/360MoveData/Users/Administrator/Pictures/%E5%8D%9A%E5%AE%A2%E4%B8%93%E7%94%A8/CDN/posts/Microcomputer_Note/image-20210331183824219.png)

> 中断不重要
>

##### 无条件转移指令 JMP

**格式**：JMP d

**功能**：程序无条件转移到目标地址d去执行

**说明**：目标地址d常常用**标号**表示。

> **标号**表示方法为：标识符加冒号。例如：`A1:`

##### 子程序（过程）调用指令 CALL

**格式**：CALL d

**功能**：程序无条件转移到子程序（过程）地址d去执行并保护断点地址。 

##### 子程序（过程）返回指令 RET

**格式**： RET

​			RET n

**功能**：无条件从子程序返回。 

##### 条件转移指令

**格式**：J条件 标号

**功能**：若满足条件，则程序转移到标号地址去执行，否则继续执行下一条指令

**说明**：条件转移指令是以标志位的状态，或者是以标志位的逻辑运算结果作为转移依据的。

###### 单标志

以ZF标志位为例进行讲解，其余的标志位CF、SF、PF、OF类似。

**格式**：JZ/JE  标号

**功能**：ZF=1结果为**零**，则转移到标号所在地址

**格式**：JNZ/JNE 标号

**功能**：ZF=0结果为**非零**，则转移到标号所在地址

```c
if (AL == BL)
	AL =- AL;
else
	AL--;
...
```

C程序👉汇编语言：

```assembly
    CMP	AL,BL
    JNZ	A1
    NEG	AL
    JMP	A2
A1: DEC	AL
A2: ...
```

###### 无符号数

JA   标号   ;两数比较，高于则转移（JNBE）

JNA 标号   ;两数比较，不高于则转移（JBE）

JB   标号    ;两数比较，低于则转移（JNAE）

JNB 标号   ;两数比较，不低于则转移（JAE）

**功能**：比较两个**无符号数**，并根据比较结果转移

有符号数

JG   标号   ;两数比较，高于则转移（JNLE）

JNG 标号   ;两数比较，不高于则转移（JLE）

JL   标号   ;两数比较，低于则转移（JNGE）

JNL 标号   ;两数比较，不低于则转移（JGE）

**功能**：比较两个**有符号数**，并根据比较结果转移

例题：假设AL、BL中存放的是无符号的数。

如果AL>BL，将AL乘以4；

如果AL<BL，将AL高两位置1；

如果AL=BL，将AL按位取反。

编写指令序列实现上述要求。

```assembly
    CMP	AL,BL
    JB	A1
    JZ	A2
    MOV	CL,2
    SHL	AL,CL
    JMP	A3
A1: OR	AL,11000000B
	JMP	A3
A2: NOT	AL
A3: ...
```

> 单双分支在本学期很常见

##### 循环指令 LOOP

**格式**：LOOP 标号

**功能**：将CX←CX－1，若CX≠0则转到标号地址去执行，否则执行下一条指令

**说明**：LOOP指令相当于下面两条指令的组合：

`DEC CX`

`JNZ 标号`

> LOOP指令通常放在循环体<u>末尾</u>。（直到型）

```c
#直到型循环：
int i=100, sum=0;
do
{
	sum=sum+i;
	i--;
} while(i>0);
...
```

C程序👉汇编语言：

```assembly
	MOV	CX,100
	MOV	AX,0
A1:	ADD	AX,CX
	LOOP A1
	...
```

例题：编写将内存以ES:1000H开始的256个字节单元清零的程序。

```assembly
		MOV	SI,1000H
		MOV	CX,256
CYCLE:	MOV	ES:[SI],BYTE PTR 0
		INC	SI
		LOOP CYCLE
```

> `BYTE PTR`👉是以**字节**去访问

例题：试编写程序，统计以DS:8000H为起始地址的连续200个字节单元中的0的个数。

```assembly
		MOV AX,0			;用AX统计0的个数
		MOV CX,200			;循环200次
		MOV SI,8000H		;通过SI间接访问内存DS:8000H开始的存储单元
CYCLE:	CMP BYTE PTR [SI],0
		JNZ NEXT
		INC AX
NEXT:	INC SI
		LOOP CYCLE
```

例题：在以DS:3301H为首地址的存储单元中，连续存放了50个无符号的字节数据，要求在其中找出最小值，并将它放在地址为DS:3300H的字节单元中。试编写程序。

```assembly
		MOV	SI,3301H	;将首地址送给SI，用SI可以间接访问数组中的元素
		MOV	AL,[SI]		;将第一个数送给AL
		MOV	CX,49		;50个数比较49次
CYCLE:	INC	SI			;让SI指向下一个数
		CMP	AL,[SI]
		JBE	NEXT		;AL<=[SI]，则判断下一个数
		MOV	AL,[SI]		;AL>[SI]，则用[SI]取代AL
NEXT:	LOOP CYCLE
		MOV	DS:[3300H],AL	;编译器会认为[3300H]就是3300H，故在前面加DS
```



#### 六、处理机控制指令

