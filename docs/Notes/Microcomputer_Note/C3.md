## **指令的格式**：

### **机器指令的格式**：

每条机器指令都由”0“和”1“组成，包含操作码和地址码。

**格式**：`[操作码] [地址码]`

操作码：说明指令的性质和功能；

地址码：说明参与运算的操作数或操作数的地址；

### **符号指令的格式**：

用符号来表示操作码和地址码。

**格式**：`[操作码助记符] [操作数助记符]`

例子：

```assembly
MOV AL,3	#把3送给AL
MOV BL,4	#把4送给BL
ADD AL,BL	#把AL和BL相加，结果送给AL
```

## 8086 CPU 寻址方式 ⭐

对于CPU，根据程序员在指令中对操作数的描述，如何找到该操作数，**即为寻址方式**

**Q**：微机中哪些地方可以存放操作数？

**A**：寄存器组，内存储器，I/O 接口。

> 包含在指令中👉**立即寻址**
>
> 存放在CPU的某个寄存器中👉**寄存器寻址**
>
> 存放在内存储器中👉**存储器寻址**
>
> 存放在I/O接口电路的端口中👉**I/O端口寻址**

### 立即寻址

**特点**：操作数直接存放在<u>指令</u>中，紧跟在操作码之后。

**表示方法**：**立即数**，也就是<u>常量</u>，二进制数、八进制数、十进制数、十六进制数均可。

> 例如：`MOV AL,05H`

### 寄存器寻址

**特点**：操作数在 CPU 内部的某个寄存器中。

**表示方法**：寄存器的名称（如 AX、BX 等）。

> 例子：`MOV AL,BL`

### 存储器寻址

**特点**：操作数存放在内存单元中。

1. 指令中如何描述操作数？

   答：在指令中用逻辑地址表示操作数。

   段地址：<u>有效地址</u>

   > 有效地址 EA（Effective Address） 可有以下三部分组成
   >
   > - 基址寄存器（BX、BP）
   >- 变址寄存器内容 （SI、DI）
   > - 位移量（8 位或 16 位立即数）
   >
   > `EA = [基址] + [变址] + [位移量]`

2. CPU 如何找到操作数？

   物理地址和逻辑地址的转换

   物理地址 PA = 段地址 × 16 + 偏移地址(EA)
   
   !> 如果偏移地址EA中含有BP，则段地址必是SS，其他一律默认DS。如果不使用默认段，则应在地址表达式前加段前缀，即“段寄存器名”。如：ES:[SI+1210H]。

#### 直接寻址

有效地址 EA 由<u>指令直接给出</u>

**表示方法**：[有效地址 EA]

物理地址：PA = (DS) × 16 + EA

> 例子：`MOV AX,[2000H]`
>
> EA=2000H，假设(DS)=3000H，那么(PA)=32000H

#### 寄存器间接寻址

有效地址 EA 由<u>某个寄存器给出</u>

**表示方法**：[**BX**]、[**BP**]、[SI]、[DI]

物理地址：

PA = (DS) × 16 + (BX)/(SI)/(DI)

PA = (SS) × 16 + (BP)

> 例子：`MOV AX,[BX]`

#### 基址寻址

**表示方法**：[基址寄存器 + 位移量]

**物理地址**：

PA = (DS) × 16 + (**BX**)

PA = (SS) × 16 + (**BP**)

> 例子：
>
> ```assembly
> MOV  AX, [BX+3]	;源操作数在数据段 
> MOV  AX, 3[BX]
> MOV  [BP]，DI	;目的操作数在堆栈段
> ```

#### 变址寻址

**表示方法**：[变址寄存器 + 位移量] 

**物理地址**：PA=(DS) × 16 + (**SI**)/(**DI**)

> 例子：
>
> ```assembly
> MOV  AX, [SI+1000H] ;源操作数在数据段 
> MOV  [DI+200H]，CL	;目的操作数在数据段
> ```
>
> 注意：变址寄存器不单独出现，还要加上位移量

#### 基址变址寻址

**表示方法**：[基址寄存器 + 变址寄存器]

**物理地址**：

PA=(DS) × 16 + (BX) + (变址寄存器)

PA=(SS) × 16 + (BP) + (变址寄存器)

> 例子：
>
> ```assembly
> MOV	AX, [BX+DI]	;源操作数在数据段
> MOV	CX, [BP+SI]	;源操作数在堆栈段
> ```

#### 基址变址位移寻址

**表示方法**：[基址寄存器 + 变址寄存器 + 位移量]

**物理地址**：

PA=(DS) × 16 + (BX) + (变址寄存器) + 位移量

PA=(SS) × 16 + (BP) + (变址寄存器) + 位移量

> 例子：
>
> ```assembly
> MOV	AX, [BX+DI+80H]	  ;源操作数在数据段DS
> MOV	CX, [BP+SI+1200H] ;源操作数在堆栈段SS
> ```

### 跨段问题

针对当前段，各段与寄存器有关的内存寻址之间是固定搭配的。

<u>DS：BX, DI, SI</u>

<u>SS：BP</u>

但加上段前缀，可打破这种关系完成跨段操作。

例： 

MOV AX，ES：[BX] 	PA=（ES）×16+（BX）

MOV CX，SS：[SI] 	 PA=（SS）×16+（SI）

<br>

## 8086 CPU 指令系统 ⭐😱

### 指令构成的基本原则

1. 源、目的操作数的<u>字长一致</u>

   MOV AL,BX ❌

2. 源、目的操作数<u>不能同为内存单元</u>

   MOV [SI],[DI] ❌

3. 立即数不能作目的操作数

   MOV 12H,AL ❌

> “左目右源” → [目的操作数 d],[源操作数 s]

### 8086 CPU 指令分类

#### 一、数据传送指令（14 条）⭐

- 实现在寄存器、存储器及 I/O 端口之间传送数据
- 除<u>标志传送指令</u>外，指令执行结果都<u>不影响</u>标志寄存器

<img src="https://cdn.jsdelivr.net/gh/hassanblog/CDN@v20210405/posts/Microcomputer_Note/image-20210323204254049.png" alt="" style="zoom:80%;" />

##### MOV 指令

**格式**：MOV d, s

**功能**： (d) ← (s)

**说明**：将 s 的内容传送给 d，s 保持不变

> MOV 指令注意事项：
>
> 1. <u>立即数不能直接送段寄存器</u>
>
> 2. d、s 不能同为段寄存器

##### XCHG 指令

**格式**： XCHG d，s

**功能**： (d) ↔ (s)

**说明**：**交换** s 和 d 的内容，s 和 d 的<u>内容都变化</u>

> XCHG 指令注意事项：
>
> 1. 不允许使用立即数
>
> 2. 不允许使用段寄存器

##### 堆栈操作指令 PUSH 和 POP

- 堆栈是存储器中的特定区域。
- 堆栈存取规则：后进先出(**LIFO** 或 **FILO**)。
- 在堆栈中始终有一个栈顶单元，该单元的地址为 **SS:SP**。
- 堆栈操作类型：压入和弹出，均以<u>字</u>为单位进行。
- 不管压入还是弹出总是对栈顶进行操作，且栈顶指针 **SP** 会<u>自动修改</u>以保持<u>始终指向新的栈顶</u>。
- CS只能PUSH，不能POP

###### 进栈指令 PUSH

**格式**： PUSH s~16~

**功能**： SP ← SP－2，(SP) ← s~16~

**说明**：将 s 指定的 <u>16位</u> 操作数压入堆栈 。

###### 出栈指令 POP

**格式**： POP d~16~

**功能**： d~16~ ← (SP)，SP ← SP ＋ 2

**说明**：将栈顶的 <u>16</u>位 操作数弹出，送入 d。

> -2，+2 是指堆栈指针移动 2 个字节（1字节8bit，2字节16bit，正好地址段间隔就是1H）

> 堆栈操作指令注意事项：
>
> 1. 不允许使用立即数
> 2. 必须以<u>字</u>为单位（16位）

![](https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210531154557347.png)

![](https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210531154614561.png)

![](https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210531154634004.png)

![](https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210531154647646.png)

##### 查表转换指令 XLAT

**格式**： XLAT

**功能**： AL ← DS : [BX ＋ AL]

**说明**：将数据段中首单元偏移地址在 BX，顺序号在 AL 的表的内容取出送 AL。

![](https://cdn.jsdelivr.net/gh/hassanblog/CDN/posts/Microcomputer_Note/image-20210526155655992.png)

<u>XLAT 指令相当于在一个字节数组中寻找某个元素</u>：

1. 数组的首地址 → BX

2. 数组元素的下标 → AL

3. 寻找到的数组元素放在 AL 中

##### 取有效地址指令 LEA

**格式**： LEA reg~16~，mem

**功能**： reg~16~ ← mem~EA~

**说明**：将 mem 指定的存储器操作数的有效地址取至 16 位的通用寄存器 reg~16~中 。

指令分析：

LEA AX，[2012H] 	;相当于 MOV AX，2012H

LEA SI，[BX]			;相当于 MOV SI，BX

LEA DI，[BX+SI]		;无直接对应指令，DI ←（BX+SI）

LEA DX，[SI-0100H]	;无直接对应指令， DX ←（ SI-0100H ）

> LEA 指令注意事项：
>
> 1. 源操作数必须为<u>存储器寻址方式</u>
>
> 2. 目的操作数是 <u>16位</u> 通用寄存器，不能是段寄存器

##### 端口输入指令 IN

**格式**：

IN AL, port~8~

IN AL, DX; 	<u>口地址为 16 位必须送 DX</u>

IN AX, port~8~

IN AX, DX

**功能**：从 I/O 端口中读取一个或两个字节到 CPU 内的 AL 或 AX 寄存器（<u>注意此处没有AH！</u>）。

**说明**：端口操作数用该端口的地址表示。

指令分析：

IN AL, 20H 		;AL←（20H）

IN AX, 40H 		;AL←（40H），AH←（41H）

MOV DX, 03F8H

IN AL, DX 		  ;AL←（3F8H）

MOV DX, 280H 

IN AX, DX 		  ;AL←（280H），AH←（281H）

##### 端口输出指令 OUT

**格式**：

OUT port~8~, AL

OUT DX, AL 	<u>;口地址为 16位 必须送 DX</u>

OUT port~8~, AX

OUT DX, AX

**功能**：向 I/O 端口中输出一个或两个字节。

**说明**：端口操作数用该端口的地址表示。

<br>

#### 二、算术运算指令（20 条）⭐

实现加法、减法、乘法、除法、BCD 码运算后的调整

大部分指令影响标志寄存器中的状态标志位

<img src="https://cdn.jsdelivr.net/gh/hassanblog/CDN@v20210405/posts/Microcomputer_Note/image-20210323204916454.png" style="zoom:67%;" />
![](https://cdn.jsdelivr.net/gh/hassanblog/CDN@v20210405/posts/Microcomputer_Note/image-20210323205034384.png)

##### 不带进位加法指令 ADD

**格式**：ADD d, s

**功能**：(d) ← (d) + (s)

**说明**：操作数不能使用段寄存器

##### 带进位加法指令 ADC

**格式**：ADC d, s

**功能**： (d) ← (d) + (s) + CF

**说明**：将**目的操作数 d**与**源操作数 s**和**进位标志 CF**相加结果送回 d 中

例题：

设 AX ＝ 1000H，CF ＝ 1，分析以下指令的执行结果（AX=? CF=?）

（1）ADD AX，100H; <u>AX=1100H，CF=0</u>

（2）ADC AX，100H; <u>AX=1101H，CF=0</u>

（3）ADC AH，0F0H; <u>AX=0100H，CF=1</u>（<u>易错</u>）

##### 加一指令 INC

**格式**：INC d

**功能**：(d) ← (d) + 1

**说明**：将目的操作数 d 加 1 后结果送回 d 中

> **注意**：<u>INC 不影响 CF 标志</u>

例题：

设 AX ＝ 0FF00H，CF ＝ 0，则执行下列指令后，AX=? CF=?

（1）INC AX; <u>AX=0FF01H，CF=0</u>

（2）INC AH; <u>AX=0000H，CF=0</u>（<u>INC 不影响 CF 标志</u>）

##### 不带进位减法指令 SUB

**格式**：SUB d,s

**功能**： (d) ← (d) - (s)

**说明**：将目的**操作数 d**与**源操作数 s**相减结果送回 d 中

##### 带进位减法指令 SBB

**格式**：SBB d,s

**功能**： (d) ← (d) - (s) - CF

**说明**：将目的**操作数 d**与**源操作数 s**和**进位标志 CF**相减结果送回 d 中

例题：

设 AX ＝ 1101H，CF ＝ 1，则执行下列指令后，AX=? CF=?

（1）SUB AX，100H; <u>AX=1001H，CF=0</u>

（2）SBB AX，100H; <u>AX=1000H，CF=0</u>

（3）SBB AH，11H; <u>AX=0FF01H，CF=1</u>

> 第三题：估计如果借位或进位了，前面就得加个 0

##### 减一指令 DEC

**格式**：DEC d

**功能**： (d) ← (d) - 1

**说明**：将目的操作数 d 减 1 后结果送回 d 中

!> 注意：<u>DEC 不影响 CF 标志</u>

##### 取负指令 NEG

**格式**：NEG d

**功能**： (d) ← $\overline{\text{d}}$ +1

**说明**：将目的操作数<u>取负加1</u>后送回 d 中（<u>取负后一定记得加1</u>）

**例题**：

设 AX ＝ 00FFH，则执行下列指令后，AX=?

NEG AX; <u>AX = FF01H</u>

NEG AL; <u>AX = 0001H</u>

##### 比较指令 CMP

格式：CMP d，s

功能： (d) - (s)

说明：仅将<u>目的操作数 d与源操作数 s相减并判断</u>，<u>结果并不送回 d 中</u>

<br>

> 在此插个 BCD 码概念

**BCD 码**

**概念**：BCD 码（Binary-Coded Decimal）亦称二进码十进数或二 - 十进制代码。用**4位二进制数**来表示**1 位十进制数中的 0~9 这 10 个数码**。通俗点，BCD 码就是对于 8 位数字来说，<u>高 4 位和低 4 位均不超过 9 的数字</u>。

比如：89的BCD码是 10001001H，就是把89当十六进制那样转换成二进制，但其本质还是十进制。

用BCD码计算十进制加法运算时，有时候遇到高4低4超过9的BCD码，容易使十进制数计算错误，所以需要修正它，这时引出了DAA指令👇

##### 加法的压缩 BCD 码调整指令 DAA

**格式**：DAA

**功能**：对 AL 中的压缩 BCD 码加法结果进行调整。

**说明**：必须紧跟在 ADD/ADC 指令之后出现。

<img src="https://cdn.jsdelivr.net/gh/hassanblog/CDN@v20210405/posts/Microcomputer_Note/image-20210324160243732.png" alt=""  />

> <u>高低位都大于9则加 66H</u>

例题：

1. 设 AL ＝ 25H，BL ＝ 37H，问执行下列指令序列后，AL=? CF=?

   ADD AL，BL

   DAA

   > 25H+37H=5CH
   >
   > 修正：5CH+6H=62H=01100010B
   >
   > AL=62H=62~BCD~，CF=0

2. CPU 执行下列指令序列后，AL=? CF=?

   MOV AL，68H

   ADD AL，89H

   DAA

   > 68H+89H=(1)F1H （大于 9，AF=1）
   >
   > 修正：F1H+66H=(1)57H=(1)01010111B
   >
   > AL=57H=57~BCD~，CF=1 （表示结果为 157）

#### 三、逻辑运算与移位指令 ⭐

##### 逻辑运算指令

- 主要实现与、或、非、异或、测试等逻辑运算。
- 除<u>逻辑“非”指令不影响标志外</u>，其他逻辑运算指令均影响标志 SF、ZF 和 PF，而 <u>OF 和 CF 一定被置 0</u>，AF 不确定。

<img src="https://cdn.jsdelivr.net/gh/hassanblog/CDN@v20210405/posts/Microcomputer_Note/image-20210327211600621.png" style="zoom: 67%;" />

###### 逻辑“与”指令 AND

**格式**：AND d, s

**功能**： (d) ← (d) ∧ (s)

**说明**：将目的操作数 d 与源操作数 s 按位相“与”结果送回 d 中。

**特点**：“与” 运算常用于使某些位<u>清 0</u>。

例题：

写出指令完成以下要求

（1）屏蔽 AL 的 0，1 两位。

AND AL，0FCH

（2）将 AH 的高 4 位清 0。

AND AH，0FH

（3）将 BX 的低 4 位清 0。

AND BX，0FFF0H

###### 逻辑“或”指令 OR

**格式**：OR d, s

**功能**： (d) ← (d) ∨ (s)

**说明**：将目的操作数 d 与源操作数 s 按位相“或”结果送回 d 中。

**特点**：“或” 运算常用于使某些位<u>置 1</u>。

例题：

写出指令完成以下要求

（1）将 AL 的 0，1 两位置 1。

OR AL，03H

（2）将 AH 的高 4 位置 1。

OR AH，0F0H

（3）将 BX 的低 4 位置 1。

OR BX，000FH

###### 逻辑“异或”指令 XOR

**格式**：XOR d, s

**功能**： (d) ← (d) ⊕ (s)

**说明**：将目的操作数 d 与源操作数 s 按位相“异或”结果送回 d 中。

**特点**：“异或” 运算常用于使某些位<u>取反</u>。

例题：

写出指令完成以下要求

（1）对 AL 的 0，1 两位取反。

XOR AL，03H

（2）对 CL 的 1,2,3,4,5 位取反，其它位不变。

XOR CL，3EH

###### 逻辑“非”指令 NOT

**格式**：NOT d

**功能**： (d) ← (d)

**说明**：将目的操作数 d 取反后结果送回 d 中。

###### 测试指令 TEST

**格式**：TEST d, s

**功能**：(d) ∧ (s)

**说明**：将目的操作数 d 与源操作数 s <u>按位相“与”</u>，只<u>影响标志位不回送结果</u>，常用于<u>测试某些位是 0 或 1</u>。

例题：

测试 AL 的最高位是 0/1？

TEST AL，80H

若 SF=1，则 AL 最高位为 1；

若 SF=0，则 AL 最高位为 0；

若 ZF=1，则 AL 最高位为 0；

若 ZF=0，则 AL 最高位为 1；

##### 移位运算指令

- 对 8 位或 16 位的通用寄存器或存储器内容进行移位，移位次数可以为 1 ～ 255。

- 若移位次数为 1 则可直接写在指令中，若次数为 2 ～ 255 则不能直接写在指令中，必须先将次数放在寄存器 <u>CL</u> 中，指令中只能写<u>CL</u>，移位结束后 CL 的值不变。

- 影响标志 OF、SF、ZF、PF、CF，但 AF 不确定。当移位次数为 1 时，若移位结果使最高位符号位发生变化，则溢出标志 OF ＝ 1，否则 OF ＝ 0；当移位次数超过 1 时，OF 无效。

<img src="https://cdn.jsdelivr.net/gh/hassanblog/CDN@v20210405/posts/Microcomputer_Note/image-20210327213112052.png" style="zoom:80%;" />

###### 逻辑左移指令 SHL

**格式**：SHL d，count（1/CL）

**功能**：逻辑左移

**说明**：将目的操作数 d 左移 count 位，右边补 0，左边入 CF。

> 逻辑左移 1 位相当于无符号数<u>乘以 2！</u>

例题：

**BX 乘以 2：**

SHL BX，1

**BX 乘以 3：**

MOV AX，BX

SHL BX，1

ADD BX，AX

**BX 乘以 4：**

MOV CL，2

SHL BX，CL

!> 移动位置超过1，一定要先将次数MOV到CL中再来写移动

###### 逻辑右移指令 SHR

**格式**：SHR d, count（1/CL）

**功能**：逻辑右移

**说明**：将目的操作数 d 右移 count 位，左边补 0，右边入 CF。

> 逻辑右移 1 位相当于<u>无符号数除以 2！</u>

###### 算术左移指令 SAL

**格式**：SAL d，count（1/CL）

**功能**：同逻辑左移完全相同

###### 算术右移指令 SAR

**格式**：SAR d，count（1/CL）

**功能**：算术右移

**说明**：将操作数 d 的内容右移，<u>左边不变（符号位不变）</u>，右边移入 CF 中。

> 算术右移 1 位相当于<u>有符号数除以 2！</u>
>
> 符号位不变是因为这是算术右移指令，符号不能变

###### 循环左移指令 ROL

**格式**：ROL d，count（1/CL）

**功能**：循环左移

**说明**：将操作数 d 的内容左移，最高位循环移入最低位，同时最高位移入 CF。

###### 循环右移指令 ROR

**格式**：ROR d, count（1/CL）

**功能**：循环右移

**说明**：将操作数 d 的内容右移，最低位循环移入最高位，同时最低位移入 CF。

#### 四、串操作指令

省略

#### 五、控制转移指令 😱

- 控制转移指令用来控制程序的执行顺序，用于实现分支、循环、过程调用/返回、中断调用/返回等程序结构。

- CS:IP 总是指向下一条即将执行的指令的地址，通过改变 IP 和 CS 的值，可以改变程序的执行顺序，但程序中不能使用 MOV 指令直接改变 CS 和 IP 的值，只能通过**控制转移指令**实现。

![](https://cdn.jsdelivr.net/gh/hassanblog/CDN@v20210405/posts/Microcomputer_Note/image-20210331183526533.png)
![](https://cdn.jsdelivr.net/gh/hassanblog/CDN@v20210405/posts/Microcomputer_Note/image-20210331183824219.png)

> 中断不重要

##### 无条件转移指令 JMP

**格式**：JMP d

**功能**：程序无条件转移到目标地址 d 去执行

**说明**：目标地址 d 常常用**标号**表示。

> **标号**表示方法为：标识符加冒号。例如：`A1:`

##### 子程序（过程）调用指令 CALL

**格式**：CALL d

**功能**：程序无条件转移到子程序（过程）地址 d 去执行并保护断点地址。

##### 子程序（过程）返回指令 RET

**格式**： RET

RET n

**功能**：无条件从子程序返回。

##### 条件转移指令

**格式**：J 条件 标号

**功能**：若满足条件，则程序转移到标号地址去执行，否则继续执行下一条指令

**说明**：条件转移指令是以标志位的状态，或者是以标志位的逻辑运算结果作为转移依据的。

###### 单标志

以 ZF 标志位为例进行讲解，其余的标志位 CF、SF、PF、OF 类似。

**格式**：JZ/JE 标号

**功能**：ZF=1 结果为**零**，则转移到标号所在地址

**格式**：JNZ/JNE 标号

**功能**：ZF=0 结果为**非零**，则转移到标号所在地址

```c
if (AL == BL)
	AL =- AL;
else
	AL--;
...
```

C 程序 👉 汇编语言：

```assembly
    CMP	AL,BL
    JNZ	A1
    NEG	AL
    JMP	A2
A1: DEC	AL
A2: ...
```

###### 无符号数

JA 标号 ;两数比较，高于则转移（JNBE）

JNA 标号 ;两数比较，不高于则转移（JBE）

JB 标号 ;两数比较，低于则转移（JNAE）

JNB 标号 ;两数比较，不低于则转移（JAE）

**功能**：比较两个**无符号数**，并根据比较结果转移

> 速记：比如JNBE(或JA)👉(Jump if not below or equal, or above)，直接记为不小于等于则跳转，也就是大于则跳转。指令都是靠英文缩写去记意思的。

###### 有符号数

JG 标号 ;两数比较，高于则转移（JNLE）

JNG 标号 ;两数比较，不高于则转移（JLE）

JL 标号 ;两数比较，低于则转移（JNGE）

JNL 标号 ;两数比较，不低于则转移（JGE）

**功能**：比较两个**有符号数**，并根据比较结果转移

例题：假设 AL、BL 中存放的是无符号的数。

如果 AL>BL，将 AL 乘以 4；

如果 AL<BL，将 AL 高两位置 1；

如果 AL=BL，将 AL 按位取反。

编写指令序列实现上述要求。

```assembly
    CMP	AL,BL
    JB	A1
    JZ	A2
    MOV	CL,2
    SHL	AL,CL
    JMP	A3
A1: OR	AL,11000000B
	JMP	A3
A2: NOT	AL
A3: ...
```

> 单双分支在本学期很常见

##### 循环指令 LOOP

**格式**：LOOP 标号

**功能**：将 CX←CX－1，若 CX≠0 则转到标号地址去执行，否则执行下一条指令

**说明**：LOOP 指令相当于下面两条指令的组合：

`DEC CX`

`JNZ 标号`

> LOOP 指令通常放在循环体<u>末尾</u>。（直到型）

```c
#直到型循环：
int i=100, sum=0;
do
{
	sum=sum+i;
	i--;
} while(i>0);
...
```

C 程序 👉 汇编语言：

```assembly
	MOV	CX,100
	MOV	AX,0
A1:	ADD	AX,CX
	LOOP A1
	...
```

例题：编写将内存以 ES:1000H 开始的 256 个字节单元清零的程序。

```assembly
		MOV	SI,1000H
		MOV	CX,256
CYCLE:	MOV	ES:[SI],BYTE PTR 0
		INC	SI
		LOOP CYCLE
```

> `BYTE PTR`👉 是以**字节**去访问

例题⭐：试编写程序，统计以 DS:8000H 为起始地址的连续 200 个字节单元中的 0 的个数。

```assembly
		MOV AX,0			;用AX统计0的个数
		MOV CX,200			;循环200次
		MOV SI,8000H		;通过SI间接访问内存DS:8000H开始的存储单元
CYCLE:	CMP BYTE PTR [SI],0
		JNZ NEXT
		INC AX
NEXT:	INC SI
		LOOP CYCLE
```

例题⭐：在以 DS:3301H 为首地址的存储单元中，连续存放了 50 个无符号的字节数据，要求在其中找出最小值，并将它放在地址为 DS:3300H 的字节单元中。试编写程序。

```assembly
		MOV	SI,3301H	;将首地址送给SI，用SI可以间接访问数组中的元素
		MOV	AL,[SI]		;将第一个数送给AL
		MOV	CX,49		;50个数比较49次
CYCLE:	INC	SI			;让SI指向下一个数
		CMP	AL,[SI]
		JBE	NEXT		;AL<=[SI]，则判断下一个数
		MOV	AL,[SI]		;AL>[SI]，则用[SI]取代AL
NEXT:	LOOP CYCLE
		MOV	DS:[3300H],AL	;编译器会认为[3300H]就是3300H，故在前面加DS
```

#### 六、处理机控制指令

省略
